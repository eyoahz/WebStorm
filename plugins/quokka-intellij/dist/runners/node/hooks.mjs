import{readdirSync}from"node:fs";import{join}from"node:path";import{existsSync}from"node:fs";import{pathToFileURL}from"url";const pnpLoaderFilename=join(process.cwd(),".pnp.loader.mjs"),pnpLoaderExists=existsSync(pnpLoaderFilename);let pnpLoader;async function getPnpLoader(){return pnpLoader||(pnpLoader=await import(pnpLoaderFilename),pnpLoader)}function convertToPosix(t){return"win32"===process.platform?t.replace(/\\/g,"/"):t}export function setExternalLoad(t){global.$_$_externalLoad=t}export function setExternalResolve(t){global.$_$_externalResolve=t}export function findMatchingFiles(t,o,e,a){const n=[];for(const e of readdirSync(t))e.match(o)&&n.push(convertToPosix(join(t,e)));if(e&&0===n.length)throw new Error(`File '${o}' is not found in '${t}'`);if(a&&n.length>1)throw new Error(`More than one file '${o}' were found in '${t}'`);return n}export function patchFile(t,o){const e=pathToFileURL(t).toString();global.$_$esmHooksPort?global.$_$esmHooksPort.postMessage({type:"patch",url:e,patches:o}):addPatch(e,o)}export async function resolve(t,o,e){if(global.$_$_externalResolve)try{const a=await global.$_$_externalResolve(t,o,e);if(a)return a}catch(t){}if(!pnpLoaderExists)return await e(t,o,e);try{return await e(t,o,e)}catch(a){const n=(await getPnpLoader()).resolve;return await n(t,o,e)}}async function loadAndPatch(t,o,e,a){const n=await a(t,o,e);return global.$_$_esm_patches&&global.$_$_esm_patches[t]&&n.source&&(n.source=global.$_$_esm_patches[t].reduce(((o,e)=>{let a="";return e.forEach(((n,r)=>{if(!a&&-1===o.indexOf(n.from)&&!n.optional)if(n.key){e.find(((t,e)=>e!==r&&t.key===n.key&&-1!==o.indexOf(t.from)))||(a=`Initialization: Wallaby is not compatible with current version of Vitest.\nCould not find ${n.key} in vitest entry point for file ${t.toString()}.`)}else a=`Initialization: Wallaby is not compatible with current version of Vitest.\nCould not find ${n.from} in vitest entry point for file ${t.toString()}.`})),a?`throw new Error(${JSON.stringify(a)});`:e.reduce(((t,o)=>t.replace(o.from,o.to)),o)}),n.source.toString())),n}export async function load(t,o,e){if(global.$_$_externalLoad)try{return await loadAndPatch(t,o,e,global.$_$_externalLoad)}catch(t){}if(!pnpLoaderExists)return await loadAndPatch(t,o,e,e);try{const a=await loadAndPatch(t,o,e,e);if("builtin"!==a.format&&!a.source){const a=(await getPnpLoader()).load;return await loadAndPatch(t,o,e,a)}return a}catch(a){try{const a=(await getPnpLoader()).load;return await loadAndPatch(t,o,e,a)}catch(t){throw a}}}function addPatch(t,o){global.$_$_esm_patches=global.$_$_esm_patches||{},global.$_$_esm_patches[t]?global.$_$_esm_patches[t].push(o):global.$_$_esm_patches[t]=[o]}export function globalPreload(t){if(parseInt(process.versions.node.split(".")[0],10)<20)return;if(!t||!t.port)throw new Error("Unexpected globalPreload argument value");return t.port.onmessage=t=>{const{type:o,url:e,patches:a}=t.data;"patch"===o&&addPatch(e,a)},"    global.$_$esmHooksPort = port;\n  "}